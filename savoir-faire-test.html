<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Savoir Faire - Repulsion Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #111;
            --effect-color: #adadad;
            --text-color: #fff;
            --font-primary: 'Inter', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-primary);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
        }

        /* Spacer to allow scrolling before the section */
        .spacer {
            height: 50vh;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #333;
        }

        /* 
           The Scroll Container
           This controls the total scroll length of the section.
           400vh means we have 4 screens worth of scroll to get through.
        */
        .savoir-scroll-container {
            height: 400vh;
            position: relative;
        }

        /* 
           The Sticky Wrapper 
           This pins the content to the view while we scroll through the container.
        */
        .sticky-wrapper {
            position: sticky;
            top: 0;
            height: 100vh;
            width: 100%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 1;
        }

        .content-layer {
            position: relative;
            z-index: 2;
            width: 100%;
            max-width: 1200px;
            padding: 40px;
            display: flex;
            /* We can use flex or grid. Let's stack them or have a dedicated layout. */
            flex-direction: column;
            height: 100%;
            justify-content: center;
        }

        .section-title {
            font-size: 4rem;
            margin-bottom: 2rem;
            position: absolute;
            top: 10%;
            left: 5%;
        }

        .item-list {
            position: relative;
            margin-top: 100px;
            /* Space for title */
            display: flex;
            flex-direction: column;
            gap: 15vh;
            /* Initial gap, but we might absolutely position them to control appearance precisely */
        }

        /* Using a different approach for the items: 
           They overlap or are centered, appearing one by one. 
           User said "scrollando i diversi punti della lista appaiano" (scrolling the points appear).
           And "not all one after another making page long".
           This suggests they replace each other or stack up.
           Let's make them appear in a specific spot or list down but within the viewport.
        */
        .savoir-item {
            font-size: 2rem;
            opacity: 0;
            filter: blur(10px);
            transform: translate(-50%, 50px) scale(0.95);
            /* Default: Below and blurred */
            transition: opacity 0.8s ease, filter 0.8s ease, transform 0.8s ease;
            max-width: 600px;
            margin-left: auto;
            margin-right: 10%;
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            text-align: center;
            pointer-events: none;
        }

        .savoir-item.active {
            opacity: 1;
            filter: blur(0);
            transform: translate(-50%, -50%) scale(1);
            /* Center, clear */
            pointer-events: auto;
        }

        .savoir-item.prev {
            opacity: 0.1;
            filter: blur(10px);
            transform: translate(-50%, -150px) scale(0.95);
            /* Above */
        }

        .savoir-item.next {
            opacity: 0.1;
            filter: blur(10px);
            transform: translate(-50%, 50px) scale(0.95);
            /* Below (Same as default but explicit) */
        }

        /* Re-thinking the list. 
           "Scroll points appear... only after 4th point... continue scroll".
           Maybe they should be a list that builds up?
           Or a slideshow?
           Let's try "slideshow" style where one fades in, then stays or fades out.
           User said "non siano tutti uno dopo laltro rendendo la pagina lunga" -> Don't make the page long.
           So they occupy the SAME space or close to it.
        */
    </style>
</head>

<body>

    <div class="spacer">
        <h1>Scroll Down</h1>
    </div>

    <!-- The Scrollytelling Section -->
    <div class="savoir-scroll-container" id="scrollContainer">
        <div class="sticky-wrapper">
            <canvas id="c"></canvas>

            <div class="content-layer">
                <h2 class="section-title">Savoir-Faire</h2>

                <div class="savoir-item" id="item1">
                    <h3>01. Philosophy</h3>
                    <p>We believe in the power of absence. By removing the unnecessary, we highlight the essential
                        truth.</p>
                </div>

                <div class="savoir-item" id="item2">
                    <h3>02. Method</h3>
                    <p>Every pixel is placed with intention. A rigorous journey of reduction.</p>
                </div>

                <div class="savoir-item" id="item3">
                    <h3>03. Vision</h3>
                    <p>Digital spaces that feel like physical sanctuaries. Quiet, profound, enduring.</p>
                </div>

                <div class="savoir-item" id="item4">
                    <h3>04. Execution</h3>
                    <p>Bridging art and utility. Seamless, beautiful engineering.</p>
                </div>
            </div>
        </div>
    </div>

    <div class="spacer">
        <h1>Continue Scrolling...</h1>
    </div>

    <script>
        let isSectionLocked = false; // Global flag for background effect

        // === CANVAS REPULSION EFFECT ===
        (function () {
            let parameters = {
                size: 40,        // Grid size
                radius: 1.5,     // Dot radius
                proximity: 125,  // Mouse influence range
                growth: 40,      // Max growth
                ease: 0.08,      // Easing
            };

            class Point {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                }
            }

            class Circle {
                constructor(radius, x, y) {
                    this._radius = radius;
                    this.radius = radius;
                    this.growthValue = 0;
                    this.position = new Point(x, y);
                }

                draw(context, ease) {
                    this.radius += ((this._radius + this.growthValue) - (this.radius)) * ease;
                    context.moveTo(this.position.x, this.position.y);
                    context.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
                }

                addRadius(value) {
                    this.growthValue = value;
                }

                get x() { return this.position.x; }
                get y() { return this.position.y; }
            }

            let circles = [];
            const canvas = document.getElementById("c");
            const context = canvas.getContext("2d");

            function init() {
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("mousemove", mouseMoveHandler);
                // Also listen for mouse move on window generally, but proximity handles coordinates
                resizeHandler();
                animate();
            }

            function build() {
                circles = [];
                const { size, radius } = parameters;
                const columns = Math.ceil(window.innerWidth / size) + 1;
                const rows = Math.ceil(window.innerHeight / size) + 1;
                const amount = Math.ceil(columns * rows);
                for (let i = 0; i < amount; i++) {
                    const column = i % columns;
                    const row = ~~(i / columns);
                    circles.push(new Circle(radius, size * column, size * row));
                }
            }

            function mouseMoveHandler(event) {
                // RESTRICTION: Only calculate repulsion if locked
                if (!isSectionLocked) {
                    return;
                }
                const { proximity, growth } = parameters;
                for (let c of circles) {
                    let distance = Math.sqrt(Math.pow(c.x - event.clientX, 2) + Math.pow(c.y - event.clientY, 2));
                    let d = map(distance, c._radius, c._radius + proximity, growth, 0);
                    if (d < 0) d = 0;
                    c.addRadius(d);
                }
            }

            function animate() {
                context.fillStyle = "#111111"; // Primary Background
                context.fillRect(0, 0, window.innerWidth, window.innerHeight);

                context.save();
                context.beginPath();
                context.fillStyle = "#ADADAD"; // Secondary Effect Color

                // If not locked, ensure growthValue resets so dots return to grid
                if (!isSectionLocked) {
                    for (let c of circles) {
                        c.addRadius(0); // Force target growth to 0
                    }
                }

                for (let circle of circles) {
                    circle.draw(context, parameters.ease);
                }
                context.fill();
                context.restore();

                requestAnimationFrame(animate);
            }

            function resizeHandler() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                build();
            }

            function normalize(value, min, max) {
                return (value - min) / (max - min);
            }

            function interpolate(value, min, max) {
                return min + (max - min) * value;
            }

            function map(value, min1, max1, min2, max2) {
                return interpolate(normalize(value, min1, max1), min2, max2);
            }

            init();
        })();

        // === SCROLL LOGIC ===
        (function () {
            const container = document.getElementById('scrollContainer');
            const items = [
                document.getElementById('item1'),
                document.getElementById('item2'),
                document.getElementById('item3'),
                document.getElementById('item4')
            ];

            function handleScroll() {
                const rect = container.getBoundingClientRect();
                const viewportHeight = window.innerHeight;

                // Calculate progress: how far the top of the container has scrolled up 
                // relative to the total scrollable distance (height - 1 screen).
                // When rect.top is 0, progress is 0.
                // When rect.bottom is viewportHeight, progress is 1.

                const totalScrollDistance = rect.height - viewportHeight;
                const scrolledDistance = -rect.top;

                let progress = scrolledDistance / totalScrollDistance;

                // Clamp progress between 0 and 1
                if (progress < 0) progress = 0;
                if (progress > 1) progress = 1;

                // Update Background Lock State
                if (rect.top <= 0 && rect.bottom >= viewportHeight) {
                    isSectionLocked = true;
                } else {
                    isSectionLocked = false;
                }

                let activeIndex = -1;

                if (progress < 0.25) activeIndex = 0;
                else if (progress < 0.50) activeIndex = 1;
                else if (progress < 0.75) activeIndex = 2;
                else activeIndex = 3;

                items.forEach((item, index) => {
                    item.classList.remove('active', 'prev', 'next');

                    if (index === activeIndex) {
                        item.classList.add('active');
                    } else if (index === activeIndex - 1) {
                        item.classList.add('prev');
                    } else if (index === activeIndex + 1) {
                        item.classList.add('next');
                    }
                });
            }

            window.addEventListener('scroll', handleScroll);
            handleScroll(); // Init
        })();
    </script>
</body>

</html>